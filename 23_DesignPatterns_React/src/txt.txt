1. Creational Patterns

Creational patterns deal with object creation mechanisms. One commonly used creational pattern in React is the Factory Pattern.
Example: Factory Pattern

The Factory Pattern can be used to dynamically create React components.

jsx

import React from 'react';

// Define a set of components
const Button = (props) => <button {...props}>{props.label}</button>;
const Link = (props) => <a href={props.href}>{props.label}</a>;
const TextInput = (props) => <input type="text" {...props} />;

// Component factory
const componentFactory = (type, props) => {
  const components = {
    button: Button,
    link: Link,
    textInput: TextInput,
  };
  const Component = components[type];
  return Component ? <Component {...props} /> : null;
};

// Usage example
const App = () => (
  <div>
    {componentFactory('button', { label: 'Click Me' })}
    {componentFactory('link', { href: '#', label: 'Go to Link' })}
    {componentFactory('textInput', { placeholder: 'Enter text' })}
  </div>
);

export default App;

2. Structural Patterns

Structural patterns deal with object composition. One commonly used structural pattern in React is the Decorator Pattern (often implemented as Higher-Order Components or HOCs).
Example: Decorator Pattern

The Decorator Pattern can be used to enhance components with additional functionality.

jsx

import React from 'react';

// Simple component
const Button = ({ onClick, label }) => <button onClick={onClick}>{label}</button>;

// HOC to log clicks
const withClickLogger = (WrappedComponent) => {
  return class extends React.Component {
    handleClick = (event) => {
      console.log('Button clicked');
      this.props.onClick && this.props.onClick(event);
    };

    render() {
      return <WrappedComponent {...this.props} onClick={this.handleClick} />;
    }
  };
};

// Enhanced component
const ButtonWithLogging = withClickLogger(Button);

// Usage example
const App = () => (
  <div>
    <ButtonWithLogging label="Click Me" />
  </div>
);

export default App;

3. Behavioral Patterns

Behavioral patterns deal with communication between objects. One commonly used behavioral pattern in React is the Observer Pattern (often implemented with hooks like useEffect and useState).
Example: Observer Pattern

The Observer Pattern can be used to react to state changes.

jsx

import React, { useState, useEffect } from 'react';

// Observable component
const Timer = ({ onTick }) => {
  useEffect(() => {
    const interval = setInterval(() => {
      onTick(new Date().toLocaleTimeString());
    }, 1000);
    return () => clearInterval(interval);
  }, [onTick]);

  return null;
};

// Observer component
const Clock = () => {
  const [time, setTime] = useState(new Date().toLocaleTimeString());

  return (
    <div>
      <h1>Current Time: {time}</h1>
      <Timer onTick={setTime} />
    </div>
  );
};

export default Clock;

Conclusion

These are just a few examples of how Gang of Four design patterns can be implemented in a React application. Each pattern serves a different purpose and can help in making your React components more reusable, maintainable, and easier to understand. The key is to understand the principles behind each pattern and apply them in a way that makes sense for your specific use case.